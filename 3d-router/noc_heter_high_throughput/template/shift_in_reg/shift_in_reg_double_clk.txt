-------------------------------------------------------------------------------
-- Title      : This shift_in_reg component use slow clock for sync. beside the fast clock
-- Project    : 
-------------------------------------------------------------------------------
-- File       : shift_in_reg_double_clk.vhd
-- Author     : Studi-IDS-103  <s_ids103@item0108.item.uni-bremen.de>
-- Company    : 
-- Created    : 2019-05-16
-- Last update: 2019-05-20
-- Platform   : 
-- Standard   : VHDL'87
-------------------------------------------------------------------------------
-- Description: 
-------------------------------------------------------------------------------
-- Copyright (c) 2019 
-------------------------------------------------------------------------------
-- Revisions  :
-- Date        Version  Author  Description
-- 2019-05-16  1.0      s_ids103        Created
-------------------------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;
use ieee.std_logic_misc.all;
use ieee.numeric_std.all;
use ieee.math_real.all;
use work.NOC_3D_PACKAGE.all;
------------------------------------------------------------------------------------------

entity shift_in_reg_double_clk is

  generic (
    N  : integer := $flit_size;
    cf : integer := $cf
    );
  port (
    data_in        : in  std_logic_vector(N-1 downto 0);     -- input data
    valid_input    : in  std_logic;                          -- write enable
    clk, sclk, rst : in  std_logic;                          -- sclk is slow clock
    data_out       : out std_logic_vector(cf*N-1 downto 0);  -- output data
    valid_data     : out std_logic                           -- buffer not empty
    );

end shift_in_reg_double_clk;

------------------------------------------------------------------------------------------
architecture rtl of shift_in_reg_double_clk is

  ----------------------------------------------------------------------------------------
  -- Internal signal declarations
  ----------------------------------------------------------------------------------------
  signal valid_counter                   : unsigned(integer(ceil(log2(real(cf))))-1 downto 0) := (others => '0');
  type   reg_type is array (natural range<>) of std_logic_vector(N-1 downto 0);
  signal shift_reg                       : reg_type(cf-2 downto 0);
  signal update_reg                      : reg_type(cf-1 downto 0);
  signal valid_data_reg, update_reg_full : std_logic;
  signal update_reg_full_sig             : std_logic;
begin

  FLIT_SPLIT : for i in 0 to cf-1 generate
    data_out(N-1+i*N downto i*N) <= update_reg(i);
  end generate;


  process(clk, rst)
    variable valid_counter_int   : integer range 0 to cf-1;
    variable update_reg_full_var : std_logic := '0';
  begin
    if rst = RST_LVL then
      shift_reg       <= (others => (others => '0'));
      valid_counter   <= (others => '0');
      update_reg      <= (others => (others => '0'));
      update_reg_full <= '0';
    elsif clk'event and clk = '1' then
      valid_counter_int   := to_integer(valid_counter);
      update_reg_full_var := update_reg_full;
      ------------------------------------------------------------------------------------
      -- Shifting the data and receiving new data when the number of data is less than cf
      ------------------------------------------------------------------------------------
      if valid_input = '1' and valid_counter_int /= cf-1 then
        SHIFT_GEN : for i in cf-2 downto 1 loop
          shift_reg(i-1) <= shift_reg(i);
        end loop;
        shift_reg(cf-2)   <= data_in;
        valid_counter_int := valid_counter_int+1;
        -------------------------------------------------------------------------------------
        -- If cf valid data exist, then send all to update register and wait rising edge of
        -- slow clock to send data out
        -------------------------------------------------------------------------------------
      elsif valid_input = '1' and (valid_counter_int) = cf-1 then
        update_reg(cf-2 downto 0) <= shift_reg;
        update_reg(cf-1)          <= data_in;
        update_reg_full_var       := '1';
        valid_counter_int         := 0;
      end if;
      valid_counter <= to_unsigned(valid_counter_int, integer(ceil(log2(real(cf)))));
      if valid_data_reg = '1' then
        update_reg_full_var := '0';
      end if;
      update_reg_full <= update_reg_full_var;
    end if;
  end process;

  process(sclk, rst)
  begin
    if rst = RST_LVL then
      valid_data_reg <= '0';
    elsif sclk'event and sclk = '1' then
      -- valid_data_reg <= update_reg_full_sig;
      valid_data_reg <= update_reg_full;
    end if;
  end process;

  --process(clk, rst)
  --begin
  --  if rst = RST_LVL then
  --    update_reg_full <= '0';
  --  elsif clk'event and clk = '1' then
  --    update_reg_full <= '-';
  --    if valid_data_reg = '1' then
  --      update_reg_full <= '0';
  --    elsif valid_input = '1' and to_integer(valid_counter) = cf-1 then
  --      update_reg_full <= '1';
  --    end if;
  --  end if;
  --end process;

--update_reg_full_sig <= '0' when valid_data_reg = '1' else
--                       '1' when valid_input = '1' and to_integer(valid_counter) = cf-1 else
--                       '-';
  valid_data <= valid_data_reg;
end rtl;

--architecture str of shift_in_reg_double_clk is

--  ----------------------------------------------------------------------------------------
--  -- Internal signal declarations
--  ----------------------------------------------------------------------------------------
--  signal valid_counter       : unsigned(integer(ceil(log2(real(cf))))-1 downto 0) := (others => '0');
--  type   reg_type is array (natural range<>) of std_logic_vector(N-1 downto 0);
--  signal shift_reg           : reg_type(cf-2 downto 0);
--  signal update_reg          : reg_type(cf-1 downto 0);
--  signal valid_data_reg      : std_logic;
--  signal update_reg_full_sig : std_logic;
--begin

--  FLIT_SPLIT : for i in 0 to cf-1 generate
--    data_out(N-1+i*N downto i*N) <= update_reg(i);
--  end generate;


--  process(clk, rst)
--    variable valid_counter_int   : integer range 0 to cf-1;
--    variable update_reg_full_var : std_logic;
--  begin
--    if rst = RST_LVL then
--      shift_reg     <= (others => (others => '0'));
--      valid_counter <= (others => '0');
--      update_reg    <= (others => (others => '0'));
--    elsif clk'event and clk = '1' then
--      valid_counter_int := to_integer(valid_counter);
--      ------------------------------------------------------------------------------------
--      -- Shifting the data and receiving new data when the number of data is less than cf
--      ------------------------------------------------------------------------------------
--      if valid_input = '1' and valid_counter_int /= cf-1 then
--        SHIFT_GEN : for i in cf-2 downto 1 loop
--          shift_reg(i-1) <= shift_reg(i);
--        end loop;
--        shift_reg(cf-2)   <= data_in;
--        valid_counter_int := valid_counter_int+1;
--        -------------------------------------------------------------------------------------
--        -- If cf valid data exist, then send all to update register and wait rising edge of
--        -- slow clock to send data out
--        -------------------------------------------------------------------------------------
--      elsif valid_input = '1' and (valid_counter_int) = cf-1 then
--        update_reg(cf-2 downto 0) <= shift_reg;
--        update_reg(cf-1)          <= data_in;
--        valid_counter_int         := 0;
--      end if;
--      valid_counter <= to_unsigned(valid_counter_int, integer(ceil(log2(real(cf)))));
--    end if;
--  end process;

--  process(sclk, rst)
--  begin
--    if rst = RST_LVL then
--      valid_data_reg <= '0';
--    elsif sclk'event and sclk = '1' then
--      valid_data_reg <= update_reg_full_sig;
--    end if;
--  end process;
--  update_reg_full_sig <= '1' when valid_input = '1' and valid_counter = cf else
--                         '0';
--  valid_data <= valid_data_reg;
--end str;

------------------------------------------------------------------------------------------
